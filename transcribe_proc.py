import batchalign as ba
from tkinter import messagebox
import os
import subprocess
import sys
import json
import traceback
from types import FunctionType
from huggingface_hub.hf_api import repo_exists as is_valid_model_id
import pycountry
import soundfile
# from CustomAiEngine import CustomAiEngine

DEBUG_MODE = True

DEBUG_LINE_PREFIX = "@DEBUG"
DEBUG_PREAMBLE = "\n".join([f"{DEBUG_LINE_PREFIX} {line}" for line in [
        ('-' * 10 + ' DEBUG LOGS ' + '-' * 10),
        f'The following block of {DEBUG_LINE_PREFIX} lines are autogenerated by the transcriber application.',
        f'If all steps are SUCCESSFUL, then no errors occurred.',
        f'If a debug step line is followed by a bunch of seemingly gibberish, then it is the error message for what went wrong.',
        f'You may remove the {DEBUG_LINE_PREFIX} lines if you wish, but if you are reporting an error to the maintainer, please include these lines.',
        ('-' * 10 + ' DEBUG LOGS ' + '-' * 10),
    ]])

def debug_get_version() -> str:
    """
    Returns: a version string for the active transcriber (will also tell us if the user has changed any files)
    """
    try:
        commit_hash = subprocess.check_output(['git', '-C', os.path.dirname(__file__), 'rev-parse', 'HEAD']).decode('ascii').strip()
        diffs = ", ".join([f'*{fn}' for fn in subprocess.check_output(['git', '-C', os.path.dirname(__file__), 'diff', '--name-only']).decode('ascii').strip().replace('\r\n','\n').split('\n')])
        return f'{commit_hash} | {diffs}'
    except subprocess.CalledProcessError as e:
        return f'UNKNOWN-NON-GIT'


def open_file(file_path):
    # this process is blocking so we dont do it for now so that we can run through the rest of the files given by the UI component
    try:
        # win & mac
        subprocess.call(["open", file_path])
    except:
        try:
            # Linux
            subprocess.call(["xdg-open", file_path])
        except:
            try:
                # win
                os.startfile(file_path)
            except:
                print(f"READY TO OPEN FILE: {file_path}", flush=True)

def spawn_popup_activity(title, message, yes=None, no=None):
    result = messagebox.askyesno(title=title, message=message)
    if result and yes and type(yes) == FunctionType:
        return yes()
    elif not result and no and type(no) == FunctionType:
        return no()


def transcribe_file(input_file, model_name=None, num_speakers=2, lang="eng"):
    debug_logs = []
    debug_logs.append(f"Transcriber version: {debug_get_version()}")
    debug_logs.append(f"Args: {input_file} {model_name} {num_speakers} {lang}")

    try:
        num_speakers = int(num_speakers)
    except:
        num_speakers = 2
    try:
        lang = pycountry.languages.lookup(lang).alpha_3
    except:
        lang = 'eng'
    # transcribe
    # whisper = CustomAiEngine(model=model_name, lang=lang)
    whisper = ba.WhisperEngine(model=model_name, lang=lang)

    # split by speaker
    diarization = ba.NemoSpeakerEngine(num_speakers=num_speakers)

    # recognize pauses
    disfluency = ba.DisfluencyReplacementEngine()

    # retrace for verbal backtracking/repetition
    retrace = ba.NgramRetraceEngine()
    
    # morphotag to get %mor %gra etc.
    morphosyntax = ba.StanzaEngine()

    # align
    utr = ba.WhisperUTREngine()
    fa = ba.Wave2VecFAEngine()

    pipeline_activity = [action for action in [
        # README: this is the pipeline that is actually run, 
        # comment out each line for what you want to be run or not
        # @todo: make this a text config file?
        whisper,
        diarization if num_speakers > 1 else None,
        disfluency,
        retrace,
        # morphosyntax,
        utr,
        fa
    ] if action]
    
    n = 0
    output_file = f"{input_file}{'_'+str(n) if n > 0 else ''}.cha"
    while 1:
        output_file = f"{input_file}{'_'+str(n) if n > 0 else ''}.cha"
        if not os.path.exists(output_file):
            break
        n += 1
    doc = ba.Document.new(media_path=input_file, lang=lang)
    for idx, activity in enumerate(pipeline_activity, start=1):
        step_status = ["Started"]
        nlp = ba.BatchalignPipeline(activity)
        try:
            print(f"{input_file} - starting pipeline action: {idx}/{len(pipeline_activity)} - {(type(activity).__name__).replace('Engine','')}")
            doc = nlp(doc)
            chat = ba.CHATFile(doc=doc)
            chat.write(output_file, write_wor=False)
            step_status = ["SUCCESSFUL"]
        except Exception as e:
            step_status = traceback.format_exc().split("\n")
            # using the soundfile LibsndfileError is not required if you want to run bare-bones
            if isinstance(e, soundfile.LibsndfileError):
                step_status.append("The input file type is not supported! Please convert the file type manually and try again!")
            print(f"{input_file} had an error on step: {idx}/{len(pipeline_activity)} - {(type(activity).__name__).replace('Engine','')}")
            traceback.print_exc()
        
        for i, line in enumerate(step_status, start=1):
            debug_logs.append(f"Step {idx}/{len(pipeline_activity)} - {(type(activity).__name__).replace('Engine','')} - {i}/{len(step_status)} - {line}")

        print(f"Step {idx}/{len(pipeline_activity)} - {(type(activity).__name__).replace('Engine','')}\n" + "\n".join(step_status))

    if DEBUG_MODE:
        with open(output_file,'a',encoding='utf-8') as f:
            f.write(f"\n{DEBUG_PREAMBLE}\n")
            f.write("\n".join([f"{DEBUG_LINE_PREFIX} {line}" for line in debug_logs]))
    print(f"Completed transcription for {input_file}! The output file can be found directly next to the input file in your file system with a '.cha' file extension: {output_file}", flush=True)
    # uncomment this next block if you want the output file to automatically open
    # return spawn_popup_activity(title="COMPLETED!",message=f"Completed transcription of\n{input_file}\nOutput file can be found here:\n{output_file}\nOpen file now?", yes=lambda: open_file(output_file))
    open_file(output_file)



if __name__ == "__main__":
    print(sys.argv, flush=True)
    for data in sys.argv[1:]:
        try:
            args = json.loads(data)
        except:
            print(f"Failed to parse input data: {data}")
            continue
        print("Attempting to transcribe for:", args.get('input_file',args), flush=True)
        transcribe_file(**args)
        print("Attempt completed for:", sys.argv[1:], flush=True)
